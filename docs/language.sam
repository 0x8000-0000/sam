sam:

specification: Semantic Authoring Markdown (SAM)

    introduction:

        Semantic Authoring Markdown (SAM) is a simplified markup for semantic authoring. Semantic authoring,
        in this case, means writing texts that identify some part of their semantics thought embedded
        markup.

        All markup languages, such as Markdown, have semantics of some kind, but usually they only
        cover the semantics of document structure, delineating things like sections, paragraphs, and
        lists. SAM is intended for markup that delineates things related to the subject matter of
        the content, or the more specific document structures.

        An example of a markup language that delineates things related to its subject matter is
        Javadoc, which calls out parts of a Java API routine, such as parameter values and the
        return value. However, most such languages have a fixed set of subject-specific elements
        and are intended for only one purpose. SAM is intended to support creating subject-specific
        markup languages for many subjects, as well as many specific document types.

        XML is the language most often used for defining new tagging languages, however, XML is
        verbose and difficult to read. The same readability goals that lead to the development
        of Markdown as an alternative to HTML for authoring web pages led to the creation of SAM.

        XML was not designed to be an authoring language, but a language for machines to talk
        to each other. It was assumed that human authors of XML documents would use editor that
        hid the markup. But while many such editors exist, they share a common problem that,
        when it comes to semantic markup, hiding the tagging also hides the structure. To see
        the structure, the author has to switch to looking at the raw XML. However, the raw
        XML is verbose and while the structure is present, it also gets lost in the sea tags.

        SAM is an attempt to provide a semantic authoring language that is easy to read and
        write while still making the semantic structure of the document visible. It takes its
        clues from YAML and Python (for displaying overall structure), from Markdown (for displaying
        text structures) and from common English usage (for displaying annotations.)

        SAM is not designed to be a full replacement for XML. It is far less general and it
        combines built in semantics with externally specified semantics which limit it not
        only to the particular purpose of semantic authoring, but to a particular approach
        to semantic authoring, which we could call the declarative approach the markup, meaning
        that it does not support the insertion of command to the publishing system into the
        document markup (something common in many structured authoring languages).

        It also provides for only a very limited and predefined set of attributes. This is
        deliberate, and is based both on the desire to encourage declarative markup, and
        the desire to keep the appearance of a raw SAM document readable. The intention is
        that an author writing in SAM should feel no need to use a visual editor, but should
        work directly in raw SAM (albeit with editor-supplied syntax coloring if desired).

        Markup languages such as reStructured Text and ASCIIDoc provide a fuller set of
        document markup than Markdown, but do so using a lot of punctuation characters (using
        them in eccentric ways that would not occur in a normal document). Though not as
        distracting to the eye as XML markup, this reliance of punctuation still reduces
        the readability of the documents marked up in these languages. SAM makes far less
        use of punctuation than these languages, preferring, like XML, to use words set
        off by basic punctuation to express structure. This helps SAM meet its goals of
        semantic extensibility (adding words is easier than adding punctuation) and of
        making the semantic structure visible to the author.

        A large part of the verbosity of XML comes from its requirement to close every
        element tag, and the fact that it recognizes no delimiters other than element tags.
        SAM uses markdown style text clues for things like paragraphs and lists, and
        avoids the use of end tags in all cases but one (codeblocks containing non-SAM
        markup). Where the structure would be ambiguous without end tags, SAM uses
        indentation levels to determine where structures begin and end.

        Unlike XML, SAM is line based (as is markdown). In XML, line breaks do not tell
        you anything about the structure of the document. In SAM, line breaks and
        indents are the major delineators of structure.

        SAM supports the use of schemas to specify the allowed structure of a document type.
        The parser can use the schema to determine when a structure is complete, reducing
        the need for indenting. If you use SAM without a schema, you will need to use indenting
        throughout to correctly represent structure.

        While XML has only one unit of structure, the element, SAM has several:

        |blocks| Blocks are elements that contain other elements. For instance, a section is a block.

        |fields| Fields are elements that contain individual values. For instance, the title of a document
        is usually a field.

        |flows| Flows are sequences of text. Paragraphs are flows. Flows cannot contain blocks or fields.

        |record sets|

        |strings| Strings are flows that have been assigned a name so that they can be included by
        reference in other parts of a document or in other documents.

        |fragments| Fragments are sections of a documents (potentially larger than a single flow)
        that can be included by reference in other parts of a document or in other documents. Strings
        used in a fragment can be redefined when a fragment is reused, allowing you to vary the
        text of the fragment when it is used in different places.

        |annotations| Annotations are elements within a flow that have been annotated with semantic
        metadata to indicate something about their subject matter.

        |insertions|


    section: Annotations

        Annotations clarify what a piece of text is about. The annotated text
        is placed in square brackets, and the annotation follows immediately
        in parentheses. (There must be no space between the closing square bracket
        and the opening parentheses.)

        ```(sam)
        In [Rio Bravo](movie), [the Duke](actor "John Wayne" (SAG)) plays
        a union colonel.
        ```

        There are three parts to the annotation:

        |type| The first word immediately following the opening
        parentheses is the type of the subject being annotated. In the sample
        above, "Rio Bravo" is a movie and "the Duke" is an actor.

        |specifically| In some cases, the annotated text may not specify the
        subject clearly. In this case, the specifically attribute is use
        to clarify what is meant. In the sample above, "the Duke" means, specifically,
        "John Wayne".

        |namespace| In some cases, it is necessary to specify the namespace to which
         the annotated term belongs. In the sample above, the name of the actor
         "John Wayne" is part of a set of names managed by the Screen Actors Guild
         which makes sure two actors don't use the same stage name. (In most cases,
         the namespace is implied by the type, so you will not usually need to
         specify it.)

    section: Repeated annotations

        If you are annotating the same phrase more than one in the same file. You
        can skip the annotation metadata and just use square brackets around the phrase.
        The parser will
        copy the metadata from the last occurring instance of that same phrase.

        ```(sam)
        [foo](bar "baz") gruznatz [foo]
        ```

	section: Inserts

	    Insertions are indicated by >> followed by parentheses containing the type and identity of the
	    thing to be inserted. SAM knows nothing about the types of things you might
	    insert. It simply passes on the type to the processing application.

	    The parameters of an insertion are different from those of an annotation. They are:

	    1. the type of the annotation
	    2. the URI of the material to be inserted
	    4. an id, consisting of a # followed by a name (such as "#foo")
	    5. one or more conditions, consisting of ? followed by a token

    section: Conditions

        Conditions are indicated in annotations, blocks, and inserts using a question mark followed
        by a token.

        SAM itself does not execute conditions, it merely encodes them for later
        processing. Therefore it has no idea what the tokens mean or how they will
        be interpreted. However, using simple tokens is recommended as a best practice.


    section: Blocks

        Blocks are indicated by a token followed by a semicolon at the start of a line.

        Blocks can have metadata in parens that follow the colon with no space:

        ```
        section:(?ultra)
            The ultra feature is really cool!
        ```

        Block metadata can include:

        * Condition token, which start with a ?
        * IDs, which start with #
        * A string, in quotes, known as the specifically attribute. The specifically
        attribute exists to specify and clarify what is being annotated.

     section: Fragments

        Fragments are created by a token followed by an open curly brace at the start
        of a line:

        ```sam
        {#my-fragment ?bar

            $foo=Bar bar black sheep

            Some stuff. >>($foo)

            Some more stuff.
        }
        ```

        The content of the fragment must be indented, and the closing brace must
        be at the same indentation level as the opening one.

    section: Insert a fragment

        To insert a fragment:

        ```(sam)
        >>{my-fragment}

        Any strings defined within a fragment are scoped to that fragment. You can
        override these strings when you insert the fragment. In fact, you can
        override any in-scope strings in a fragment insert. String definitions must
        each be on a line by themselves.

        >>{my-fragment
            $foo=bar
            $baz=bat
          }


        Note that the SAM syntax is designed to bear these semantics, but that the
        SAM parser does not implement them. It simply passes them on to whatever
        processor you are using, which is free to implement different rules for
        string handling.

	section: Shortcuts for inserts
        # string
		>>($this.string)
		>>(string this.string)

		# reference
		>>(#this.ref)
		>>(ref this.ref)


    section: Blockquotes

    Three quotation marks in a row are a shortcut for the implicit
    element "blockquote".

    ```(sam)
    """(citation)
        Quoted
    ```

    You can achieve the same effect by using the literal name blockquote
    (which is then just like any other block element, except that its
    attribute is recognized as a citation):

    ```(sam)
    blockquote:(citation)
        Quoted
    ```


    section: Alternate blockquotes

    Standard blockquotes may conflict with embedding in other languages such as
    Python docstrings.

    ```(sam)
    '''(citation)
        Quoted


    The difference between code ``` and quote """ is that code signals a different
    encoding. The content of the code block is not processed as sam markup until
    the closing ``` is seen.

    In the event that the end marker for the codeblock would appear in the
    codeblock, the writer can add arbitrary characters after
    ``` in the top and bottom markers to assure they are distinct.

    In a blockquote, however, the material inside the quote block is still SAM
    markup and is processed as such.

section: Lists

    You can create any kind of list you like by using nested blocks.

    ```(SAM)
    ul:
        li: Dog
        li: Hen
        li: Spoon

    ```

    Shortcuts for ordered and unordered lists are supported.

    Unordered lists begin with a line starting with an asterisk.

    ```(SAM)
    * Dog
    * Hen
    * Spoon
    ```

    Ordered lists begin with a number followed by a period.

    ```(SAM)
    0. Robot
    12. Spaceship
    7. Ray gun
    ```

    Labeled lists begin with a label between pipe characters.

    ```(SAM)
    |fa| A long long way to run.
    |so| A needle pulling thread.
    |la| A note to follow so.
    ```


    Lists continue until:

    * The next non-blank line at the same indent that does not start with a list marker.
    * The next non-blank line that is less indented.
    * The end of the file.

    List items continue until:

    * The next para at the same indent that starts with a list marker.
    * The end of the list.

section: Reserved insert types

    ref
    string
    image
    video
    audio
    feed

    These are reserved so that editors can act on them.

section: Whitespace handling
    All flows are trimmed of leading and trailing whitespace. In composing a flow
    from multiple text lines, all spaces and returns are collapsed to a single
    space.

    In codeblocks, all whitespace is retained. However, codeblocks do not have
    to follow the indenting of the rest of the document, so you can left-align
    code to achieve correct indenting of the code itself.